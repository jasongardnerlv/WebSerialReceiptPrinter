class t{constructor(t){this._events={}}on(t,e){this._events[t]=this._events[t]||[],this._events[t].push(e)}emit(t,...e){let s=this._events[t];s&&s.forEach((t=>{setTimeout((()=>t(...e)),0)}))}}class e{}class s extends e{#t;#e={};#s=null;#i=null;#r=[];#n={running:!1,closing:!1};constructor(e){super(),this.#t=new t,this.#e=Object.assign({baudRate:9600,bufferSize:255,dataBits:8,flowControl:"none",parity:"none",stopBits:1},e),navigator.serial.addEventListener("disconnect",(t=>{this.#s==t.target&&this.#t.emit("disconnected")}))}async connect(){let t=await navigator.serial.requestPort();if(!t)throw new Error("Could not connect! No port available");await this.open(t)}async reconnect(t){if(!t.vendorId||!t.productId)return;let e=(await navigator.serial.getPorts()).filter((e=>{let s=e.getInfo();return s.usbVendorId==t.vendorId&&s.usbProductId==t.productId}));1==e.length&&await this.open(e[0])}async open(t){this.#s=t,this.#n.closing=!1,await this.#s.open(this.#e);let e=this.#s.getInfo();this.#t.emit("connected",{type:"serial",vendorId:e.usbVendorId||null,productId:e.usbProductId||null,language:null,codepageMapping:null})}async disconnect(){this.#s&&(this.#n.closing=!0,this.#i&&(this.#i.cancel(),await this.#i.closed),await this.#s.close(),this.#s=null,this.#t.emit("disconnected"))}async listen(){return this.#a(),!0}async#a(){for(;this.#s.readable&&!1===this.#n.closing;){this.#i=this.#s.readable.getReader();try{for(;;){const{value:t,done:e}=await this.#i.read();if(e)break;t&&this.#t.emit("data",t)}}catch(t){}finally{this.#i.releaseLock()}}}async print(t){this.#r.push(t),this.run()}async run(){if(this.#n.closing)return;if(this.#n.running)return;this.#n.running=!0;const t=this.#s.writable.getWriter();let e;for(;e=this.#r.shift();)await t.write(e);t.releaseLock(),this.#n.running=!1}addEventListener(t,e){this.#t.on(t,e)}}export{s as default};
//# sourceMappingURL=webserial-receipt-printer.esm.js.map
